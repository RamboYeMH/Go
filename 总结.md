## Java 

 

1.Java中的引用类型 强软弱虚

-  Java中的引用类型有哪些

Java中的引用就是指针，指向一个地址空间

强引用：只要这个引用指向了一个对象

软引用：-Xms --Xmx 当内存空间足够的时候他能在，当内存空间不够的时候可以把他GC掉

```java
SoftReference<byte[]> softReference = new SoftReference<>(new byte[1024 * 1024 * 10]);
```

**软引用非常适合缓存**，如果用一个软引用指向一个对象，当内存不足是就可以清理掉这部分内存

并且软引用只能用softRefrence来包装

弱引用：只要GC 这个引用的对象就会被干掉

```java
WeakReference<byte[]> weakReference = new WeakReference<>(new byte[10]);
```



- ThreadLoacl你了解吗

  只有自己设置进入的这个线程能够读取数据，线程私有的容器

- ThreadLoacl应用在什么地方

- ThreadLoacl会产生内存泄漏你了解吗

Java并发编程

Java常规数据模式



## Go

GMP

协程

哲学 正交 简洁



## 2. 网络

[资源1](https://www.cnblogs.com/guoxiaoyu/p/17707285.html)

### 1.TCP

1.三次握手

client      sync = 1,ack = true,seq = x              server

client                    server

client                    server

客户端请求：sync = 1 ack = 0 seq = x

服务器回复:   sync = 1 ack=1, ack_num = x + 1 seq = y

客户端请求：sync = 0 ack = 1,ack_num = y + 1,seq = x +  1

- 第一次握手（SYN = 1，seq = x）

客户端发送一个TCP的SYN标志位置1的包。指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头序列化（Sequence Number）字段里

发生完毕之后，客户端进入`syn_send` 状态

- 第二次握手（SYN = 1，ACK = 1，seq = y, Acknum = x + 1）

服务器发回确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器端选择自己ISN徐丽华，放到Seq域里，同时将确认序号（Ack num）设置为客户端的ISN加1，即X+1。发送完毕后，服务器端进入`syn_revd` 状态

- 第三次握手（ACK =1 ，ACKnum = y +  1）

客户端再次发送确认包（ACK），SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发生给对方，并且在数据段写ISN的+1

发送完毕后，客户端进入`Established` 状态，当

**TCP 头格式**

![img](asserts/TCP-Header-01.jpg)





### 2.UDP

[资料](https://www.cnblogs.com/god-of-death/p/8044359.html)

[UDP分片](https://www.cnblogs.com/cnlntr/p/16079728.html)



![img](asserts/1467537-20220330230946218-388884434.png)

**UDP的传输方式：面向报文**

面向报文的传输方式决定了UDP的数据发送方式是一份一份的，也就是应该层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。那么UDP的报文大小由哪些影响因素呐？UDP数据包的理论长度是多少，合适的UDP包应该是多少呐？

**（1）UDP报文大小的影响因素，主要有一下三个**

- UDP协议本身，UDP协议中有16位的UDP报文长度，那么UDP报文长度不能超过2^16 = 65536
- 以太网（Ethernet）数据帧的长度，数据链路层的MTU（最大传输单元）
- socket的UDP发生缓存区大小

**（2）UDP 数据包最大长度**

根据UDP协议，从UDP数据包的包头可以看出，UDP的最大包长度是2^16-1字节。由于UDP包头占8字节，而在IP层封装后的IP包占去20字节，所以这个是UDP数据包的理论最大长度是2 ^16-1-8=65507字节。如果数据包超过65507字节，send或sendto函数会错误码。如果UDP发送缓冲区大小小于65507字节，在发送一个数据包为65507字节的时候，send或sendto函数会报错错误码

**（3）UDP数据包理想长度**

理论上UDP报文最大长度是65507字节，实际上发送这么大的数据包效果最好吗？UDP是不可靠的传输协议，为了减少丢UDP包的风险，最好控制UDP包在下层协议传输过程中不要被切割。MTU 最大传输单元，这个传输单元实际上和链路层协议有着密切的关系、每个以太网帧都有最小64字节，最大不超过1518字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误数据帧

在下层数据链路层最大传输单元是1500字节的情况下，要想IP层不分包，那么UDP数据包的最大大小应该是1500字节-IP头（20字节）-UDP头（8字节） = 1472字节。**不过鉴于Internet上的标准MTU值为576字节，所以建议在进行Internet的UDP编码时，最好将UDP的数据长度控制在（576-8-20） 548字节以内**

**（4）UDP包分片问题**

如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下解包，在





HTTP

DNS

KCP

### 3.Netty

Reactor模型

零拷贝

buffer

channel



### 4.粘包拆包

断线重连

逻辑线程与IO线程

select poll epoll 

大小端

MTU 滑动窗口  

线程的上线文切换

零拷贝

## 3.并发

锁 Go中GMP 多线程

## 4.分布式

rafa

雪花算法

从主从复制

分布式锁 ZK redis

## 5.MongoDB

SQL优化 索引 B树 B+树 红黑树

分片 非关系数据库

存储引擎

SQL合并

事务



## 6.游戏相关

架构

热更

重登 补包

排行榜

## 7.Linux

如何查找线程问题 常规命令

## 8.算法

排序算法：冒泡、选择、插入、希尔、堆排序、桶排序、快速排序，归并排序

寻路算法：A*

压缩算法

动态规划

贪心

字符串相关算法

## 9.数据结构

单链表

双向链表

队列

堆栈

数组

HashMap

红黑树

多级缓存

LRU

跳表



## 10. 设计模式

1.单例

2.构建者

3.桥接

4.抽象工厂

5.工厂方法

6.命令

7.观察者

8.修饰器

9.适配器

10.享元

11.组合

12.策略

## 11.Pulsar

1.缓存行

2.内存对齐

3.ringbuff

## 12.Disruptor

消峰



## 13.GC

常规的GC算法

ZGC

G1

## 14.JVM



## 开发中遇到的问题

1.不要相信第三方接口

2.类加载器导致的maven版本

3.多个用户登录数据库导致碰撞

4.分片时大多数返回成功之后就返回成功

5.MongoBD最多一次写入15M数据

6.幂等